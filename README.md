학습 목적의 프로젝트 
------------------------------------------
frontend: nextjs(2021년 군대가기전에 react랑 redux 기본 공부했었던게 생각나서 바로 nextjs 프레임워크 사용해봄)
backend : nestjs(express 기본 공부 후 냅다 써봄)

(~ 2025.10.21)
 useEffect로 fetch로 백엔드 데이터 받아오는 과정에서 useState 이용해서 계속 isLoading, error이런거 처리하기 너무 귀찮고 계속 useState 남발하다보니
state관리하다가 정신나갈 것 같아서 react query 학습으로 넘어감 !
좀 살것 같은데 이제 모달창을 여는 과정에서 자식 컴포넌트에 계속 props 넘겨주고 () => setIsModalOpne(false) 이런거 넘겨주고 하니깐 무한 트리 지옥에 
빠지는 느낌이 들어서 이제 리덕스 써서 전역 상태관리를 해볼 예정이다. (요즘 찾아보니 리덕스 잘 안쓴고 justand 이런거 많이 쓴다던데 21년도에 배웠던게 리덕스였어서 개념도 상시키기고 상태관리 공부 목적으로
해보고 다음에는 justand나 recoil 같은 상태관리 도구들 이어 학습할 예정)

 그리고 api로 백엔드와 통신하는 과정에서 fetch() 쓰면서 하드코딩이 너무 많아지길래 axios를 도입했다. axios에서 requeset, response 인터셉터를 통해서
요청 시 jwt를 넣고, 응답시 에러처리와 response.data를 꺼내와서 바로 const user = await apiClient.get('/user/:id'), return user 이런식으로 
앞에서 굳이 return response.data로 가지 않도록 설계해보았다. 확실히 코드가 훨씬 깔끔해보이고 에러처리가 눈에 잘 보이니깐 유지보수에 유용하겠다는 것을 깨달았다.

 백엔드와 프론트엔드를 함께 만드는 과정에서 api 요청이 많아짐에따라 백엔드가 넘겨주는 데이터와 프론트에서 받는 데이터가 타입에서 좀 관리가 잘 안된다는 느낌을 많이 받았다.
좀 그 상호작용 속에서 tyepscirpt 쓰는 만큼 그 이점을 얻기위해 타입 관리나 데이터 연결과정이 좀 통일성있음 좋겠다 생각했는데 구글링 해보고 gpt한테도 물어보니
모노레포 구조라고 한 파일 안에 두개의 프로젝트를 함께 설계하는 구조가 있음을 알고 적용해보았다.
apps 안에 frontend, backend를 넣고 두개가 함께 사용하는 타입 같은거는 package/types에 정리해서 프론트엔드가 받은 return 데이터의 타입과 backend가 내는 return 값의 타입이 동일하게
지될 수 있도록 했더니 확실히 관리하기 수월해졌다. 
 모노레포구조를 어떻게 바꿨는지는 내 노션에 정리해놨으니 나중에 별도로 다시 써야겠다.
 
 이렇게 모노레포 구조를 설계한 덕분에 전에는 백엔드에서 받은 데이터를 이용하는게 불안하고, 개발과정에서 포스트에는 이런 속성이 없다 이런 에러가 많이 떴었는데, 
이제는 그런 에러가 확실히 많이 줄었고 프론트에서 백엔드에서 받은 데이터를 사용할때 조금 더 자신있게 데이터를 받아 props를 내리고 이용할 수 있게 되었다.

 (앞으로 진행하고 싶은 부분)
 -> TDD 개발 하고 싶음 
 이유: 새롭게 리팩토링하거나 기능 추가할때 기존에 있었던 로직들이 제대로 작동할까? 라는 고민에 빠졌다. 그래서 이제 기능들은 어느정도 구현 가능하니깐 
 나중에 새롭게 코드를 짜거나 리팩토링하거나 할때 기존 코드들이 잘 유지되는지 판단하는게 중요하다고 생각됐다.

 -> 그습 목적의 프로젝트 
------------------------------------------
frontend: nextjs(2021년 군대가기전에 react랑 redux 기본 공부했었던게 생각나서 바로 nextjs 프레임워크 사용해봄)
backend : nestjs(express 기본 공부 후 냅다 써봄)

(~ 2025.10.21)
 useEffect로 fetch로 백엔드 데이터 받아오는 과정에서 useState 이용해서 계속 isLoading, error이런거 처리하기 너무 귀찮고 계속 useState 남발하다보니
state관리하다가 정신나갈 것 같아서 react query 학습으로 넘어감 !
좀 살것 같은데 이제 모달창을 여는 과정에서 자식 컴포넌트에 계속 props 넘겨주고 () => setIsModalOpne(false) 이런거 넘겨주고 하니깐 무한 트리 지옥에 
빠지는 느낌이 들어서 이제 리덕스 써서 전역 상태관리를 해볼 예정이다. (요즘 찾아보니 리덕스 잘 안쓴고 justand 이런거 많이 쓴다던데 21년도에 배웠던게 리덕스였어서 개념도 상시키기고 상태관리 공부 목적으로
해보고 다음에는 justand나 recoil 같은 상태관리 도구들 이어 학습할 예정)

 그리고 api로 백엔드와 통신하는 과정에서 fetch() 쓰면서 하드코딩이 너무 많아지길래 axios를 도입했다. axios에서 requeset, response 인터셉터를 통해서
요청 시 jwt를 넣고, 응답시 에러처리와 response.data를 꺼내와서 바로 const user = await apiClient.get('/user/:id'), return user 이런식으로 
앞에서 굳이 return response.data로 가지 않도록 설계해보았다. 확실히 코드가 훨씬 깔끔해보이고 에러처리가 눈에 잘 보이니깐 유지보수에 유용하겠다는 것을 깨달았다.

 백엔드와 프론트엔드를 함께 만드는 과정에서 api 요청이 많아짐에따라 백엔드가 넘겨주는 데이터와 프론트에서 받는 데이터가 타입에서 좀 관리가 잘 안된다는 느낌을 많이 받았다.
좀 그 상호작용 속에서 tyepscirpt 쓰는 만큼 그 이점을 얻기위해 타입 관리나 데이터 연결과정이 좀 통일성있음 좋겠다 생각했는데 구글링 해보고 gpt한테도 물어보니
모노레포 구조라고 한 파일 안에 두개의 프로젝트를 함께 설계하는 구조가 있음을 알고 적용해보았다.
apps 안에 frontend, backend를 넣고 두개가 함께 사용하는 타입 같은거는 package/types에 정리해서 프론트엔드가 받은 return 데이터의 타입과 backend가 내는 return 값의 타입이 동일하게
지될 수 있도록 했더니 확실히 관리하기 수월해졌다. 
 모노레포구조를 어떻게 바꿨는지는 내 노션에 정리해놨으니 나중에 별도로 다시 써야겠다.
 
 이렇게 모노레포 구조를 설계한 덕분에 전에는 백엔드에서 받은 데이터를 이용하는게 불안하고, 개발과정에서 포스트에는 이런 속성이 없다 이런 에러가 많이 떴었는데, 
이제는 그런 에러가 확실히 많이 줄었고 프론트에서 백엔드에서 받은 데이터를 사용할때 조금 더 자신있게 데이터를 받아 props를 내리고 이용할 수 있게 되었다.

 (앞으로 추가적으로 진행하고 싶은 부분)
 -> TDD 개발 하고 싶음(지금 당장은 test 개념에 익숙해지는 것이 목표) -> 가장 중요함 !! 
 이유: 전에는 기능 자체가 어떻게 구현되는지에 대해 집중했다면 이제는 새롭게 리팩토링하거나 기능 추가할때 기존에 있었던 로직들이 제대로 작동할까? 라는 고민에 빠졌다.
 그래서 이제 기능들은 어느정도 구현 가능하니깐 
 나중에 새롭게 코드를 짜거나 리팩토링하거나 할때 기존 코드들이 잘 유지되는지 판단하는게 중요하다고 생각됐다.

 -> Optimistic UI(낙관적인 UI) & tailwindcss
 이유: 그냥 react query에서 invalid..({ queryKey : ['posts'] }) 이런식으로 하니깐 서버 응답속도가 느리면 너무 늦게 반응해서 사용자 경험이 안좋아 진다는 것을
 알았다. 그래서 onMutate 개념들을 추가로 학습해서 낙관적 ui를 구현해보고 싶은 생각이다. tailwindcss는 그냥 뭔가 내가 css 자체가 좀 약한 느낌이다. 오히려 js, ts 문법공부보다
 더 하기 싫은 놈이다. 짜증나 죽겠다.

 -> 에러처리 정리
 이유: 언제 어디서 에러 메세지를 남기고 해야하는지 좀 헷갈린다. 확실하게 정리해야 겠다.
